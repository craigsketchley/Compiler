import Data.Graph as G
import Data.Map as M
import Data.List as L
import Data.Set as S

type NodeMap = M.Map G.Vertex Node
type Statement = String

data Node 
    = Node Statement
    deriving Show

[s1,s2,s3,s4,s5,s6] = ["y = 5", "x = 3", "z = x + y", "x = x + y", "x = x + 1", "goto L7"] 
ss = L.map Main.Node [s1,s2,s3,s4,s5,s6] 

[n1,n2,n3,n4,n5,n6] = [1..6]::[Int]
ns = [n1,n2,n3,n4,n5,n6] 

e = [(n1,n2), (n2,n3), (n2, n4), (n4, n5), (n3, n6), (n5, n6)]
g = buildG (1,6) e

nmap = M.fromList (zip ns ss)



-- Control Flow Graph
-- Each node is an instruction.
-- Things to capture in a node:
-- 	- assigned variables, e.g. r2 in 'ld r2 x'										(LIVE VARIABLES & CONSTANT PROP)
-- 	- used variables, e.g. x in 'ld r2 x'											(LIVE VARIABLES & CONSTANT PROP)
-- 	- used expression, e.g. 'add' & 'r2 r3' in 'add r1 r2 r3', or 'x' in 'ld r2 x'	(AVAILABLE EXPRESSIONS)


-- | The information generated by the given node.
type Gen node info = node -> S.Set info

-- | The information killed by the given node.
type Kill = Gen


type Merge info = S.Set info -> S.Set info -> S.Set info


-- Need some way to control the direction?


genKill :: ControlFlowGraph -> Gen -> Kill -> Merge -> 
genKill graph gen kill merge = 



-- type Label = String

-- data Program 
--     = Empty
--     | Node [Program]

-- data 


-- interpret :: Statement ->  



-- out :: GenFunction -> KillFunction -> Node -> [Label]

-- in' :: Node -> [Label]
